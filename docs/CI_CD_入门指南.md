# CI/CD 入门指南 - 小白版

## 🤔 什么是 CI/CD？

### 简单理解

想象你在做作业：

**没有 CI/CD 的情况：**
- 你写完作业后，自己检查一遍就交了
- 可能有一些小错误没发现
- 老师批改时才发现问题

**有 CI/CD 的情况：**
- 你写完作业后，有一个"自动检查机器人"
- 机器人会帮你：
  - ✅ 检查格式是否正确（代码风格）
  - ✅ 检查有没有拼写错误（语法错误）
  - ✅ 检查逻辑是否正确（运行测试）
  - ✅ 检查是否能正常打包（构建）
- 只有所有检查都通过了，才允许提交

### 专业解释

- **CI (Continuous Integration)** = 持续集成
  - 每次你提交代码，自动检查代码质量
  - 自动运行测试，确保代码能正常工作

- **CD (Continuous Deployment)** = 持续部署
  - 如果检查都通过了，自动部署到服务器
  - 让新功能自动上线

## 📂 在这个项目中，CI/CD 做了什么？

### 项目结构

```
你的项目/
├── .github/workflows/ci.yml  ← CI/CD 的"剧本"（告诉机器人做什么）
├── tests/                    ← 测试文件（检查代码是否正确）
├── pyproject.toml            ← 工具配置（告诉工具怎么检查）
└── ...其他代码文件
```

## 🔄 CI/CD 完整流程（一步步解释）

### 第一步：触发条件

**什么时候会运行 CI/CD？**

当你做以下操作时：
1. ✅ 推送代码到 GitHub（`git push`）
2. ✅ 创建 Pull Request（提交代码审查）

**就像：** 你提交作业时，自动触发检查

---

### 第二步：代码质量检查（Lint & Format）

**机器人检查什么？**

#### 1. **Ruff 检查**（代码风格检查）
```
就像老师检查你的作业：
- 有没有语法错误？
- 变量名是否规范？
- 代码逻辑是否合理？
```

**实际检查：**
- 代码是否有语法错误
- 是否有未使用的变量
- 是否有潜在的问题

#### 2. **Black 检查**（代码格式化）
```
就像检查你的字迹：
- 缩进是否一致？
- 空格是否正确？
- 代码是否整齐？
```

**实际检查：**
- 代码缩进是否统一（4个空格）
- 行长度是否合适
- 代码格式是否规范

#### 3. **isort 检查**（导入排序）
```
就像整理你的书包：
- 把 import 语句按顺序排列
- 相同类型的放在一起
```

**实际检查：**
- Python 的 `import` 语句是否按顺序排列
- 标准库、第三方库、本地库是否分开

**如果检查失败：**
- ❌ CI/CD 会停止，告诉你哪里有问题
- ✅ 修复后重新提交即可

---

### 第三步：运行测试（pytest）

**测试是什么？**

就像考试题，验证你的代码是否能正常工作。

**测试文件在哪里？**
```
tests/
├── test_server.py    ← 测试服务器功能
└── test_models.py    ← 测试模型功能
```

**测试会做什么？**

1. **测试服务器端点**
   ```python
   # 测试：访问 /health 应该返回 "healthy"
   def test_health_endpoint():
       response = client.get("/health")
       assert response.status_code == 200
       assert response.json()["status"] == "healthy"
   ```

2. **测试模型管理**
   ```python
   # 测试：ModelManager 应该是单例模式
   def test_model_manager_singleton():
       manager1 = ModelManager()
       manager2 = ModelManager()
       assert manager1 is manager2  # 应该是同一个对象
   ```

3. **生成覆盖率报告**
   - 告诉你哪些代码被测试了
   - 哪些代码还没有测试

**如果测试失败：**
- ❌ CI/CD 会停止，告诉你哪个测试失败了
- ✅ 修复代码后重新提交

---

### 第四步：前端检查

**检查前端代码（React/TypeScript）**

1. **ESLint 检查**
   - 检查 TypeScript 代码是否有错误
   - 检查代码风格

2. **构建检查**
   - 尝试打包前端代码
   - 确保能正常构建

**如果检查失败：**
- ❌ 前端代码有问题，需要修复
- ✅ 修复后重新提交

---

### 第五步：构建 Docker 镜像

**Docker 是什么？**

就像打包你的应用，让它在任何地方都能运行。

**这一步做什么？**
- 根据 `docker/Dockerfile` 构建镜像
- 确保 Docker 镜像能正常构建
- 不实际推送镜像（只是测试）

**如果构建失败：**
- ❌ Dockerfile 有问题，需要修复
- ✅ 修复后重新提交

---

## 📊 完整流程图

```
你提交代码 (git push)
    ↓
┌─────────────────────────────────┐
│  GitHub 收到代码                 │
│  自动触发 CI/CD                 │
└───────────┬─────────────────────┘
            ↓
┌─────────────────────────────────┐
│ 步骤 1: 代码质量检查             │
│  ✓ Ruff (语法检查)              │
│  ✓ Black (格式检查)             │
│  ✓ isort (导入排序)             │
└───────────┬─────────────────────┘
            ↓ (通过)
┌─────────────────────────────────┐
│ 步骤 2: 运行测试                 │
│  ✓ pytest (单元测试)            │
│  ✓ 生成覆盖率报告                │
└───────────┬─────────────────────┘
            ↓ (通过)
┌─────────────────────────────────┐
│ 步骤 3: 前端检查                 │
│  ✓ ESLint (代码检查)            │
│  ✓ Build (构建测试)             │
└───────────┬─────────────────────┘
            ↓ (通过)
┌─────────────────────────────────┐
│ 步骤 4: Docker 构建              │
│  ✓ 构建镜像                      │
└───────────┬─────────────────────┘
            ↓ (通过)
┌─────────────────────────────────┐
│ ✅ 所有检查通过！                │
│ 代码可以合并/部署                 │
└─────────────────────────────────┘
```

## 🎯 实际例子

### 场景 1：你写了一段新代码

```python
# 你写的代码
def hello():
print("Hello")  # 缩进错误！
```

**CI/CD 会做什么？**
1. Black 检查：❌ 发现缩进错误
2. 停止流程，告诉你："第 2 行缩进错误"
3. 你修复后重新提交

### 场景 2：你修改了 API

```python
# 你修改了 /health 端点
@app.get("/health")
async def health():
    return {"status": "broken"}  # 改成了 "broken"
```

**CI/CD 会做什么？**
1. 代码格式检查：✅ 通过
2. 运行测试：❌ `test_health_endpoint` 失败
   - 测试期望返回 "healthy"，但你返回了 "broken"
3. 停止流程，告诉你："测试失败"
4. 你修复后重新提交

### 场景 3：一切正常

你写了一段完美的代码，所有检查都通过：
- ✅ 代码格式正确
- ✅ 没有语法错误
- ✅ 所有测试通过
- ✅ 前端构建成功
- ✅ Docker 构建成功

**结果：** 🎉 代码可以合并！

## 🛠️ 如何在本地运行这些检查？

### 在提交前，你可以自己先检查：

```bash
# 1. 检查代码风格
ruff check .

# 2. 检查代码格式
black --check .

# 3. 检查导入排序
isort --check-only .

# 4. 运行测试
pytest

# 5. 如果发现问题，自动修复
ruff check --fix .  # 自动修复可修复的问题
black .             # 自动格式化
isort .             # 自动排序导入
```

## 📍 查看 CI/CD 结果

### 在 GitHub 上查看

1. 打开你的 GitHub 仓库
2. 点击 "Actions" 标签
3. 你会看到所有 CI/CD 运行记录：
   - ✅ 绿色 = 通过
   - ❌ 红色 = 失败
   - 🟡 黄色 = 进行中

4. 点击某个记录，可以看到详细步骤：
   ```
   ✓ Code Quality Check (通过)
   ✓ Unit Tests (通过)
   ✓ Frontend Lint & Build (通过)
   ✓ Docker Image Build (通过)
   ```

## ❓ 常见问题

### Q1: CI/CD 失败了怎么办？

**A:** 
1. 点击失败的步骤，查看错误信息
2. 根据错误信息修复代码
3. 重新提交

### Q2: 为什么我的代码格式检查失败了？

**A:** 
- 可能是缩进不对、行太长等
- 运行 `black .` 自动修复格式
- 运行 `isort .` 自动排序导入

### Q3: 测试失败了怎么办？

**A:**
1. 查看测试错误信息
2. 修复代码逻辑
3. 或者修复测试（如果测试本身有问题）

### Q4: 可以跳过 CI/CD 吗？

**A:** 
- 不推荐！CI/CD 是为了保证代码质量
- 如果确实需要（紧急修复），可以在提交信息中添加 `[skip ci]`

## 🎓 总结

**CI/CD 就像你的代码"质检员"：**

1. ✅ **自动检查** - 不用手动检查，提交代码就自动运行
2. ✅ **全面检查** - 检查格式、语法、测试、构建
3. ✅ **快速反馈** - 几分钟内告诉你结果
4. ✅ **保证质量** - 只有通过所有检查的代码才能合并

**好处：**
- 🎯 减少 bug
- 🎯 保持代码风格统一
- 🎯 提高代码质量
- 🎯 团队协作更顺畅

---

**现在你理解 CI/CD 了吗？** 如果还有问题，可以查看：
- `docs/CI_CD_SETUP.md` - 详细技术文档
- `.github/workflows/ci.yml` - CI/CD 配置文件

